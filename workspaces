# this is not a standalone shell script.
: ${workspaces[@]:?This script is not intended to be executed}

set -e

PREFIX=$HOME/w

# Hold and wait for input before exiting after an error.
# So 'xterm -e workspaces open ...' don't exit immediately on error
wait_input_and_exit ()
{
  local x=$?
  echo "$@" >&2
  echo "Press enter to close." >&2
  read
  exit $x
}

open_workspace ()
{
  local wname="$1" pkg p
  p=$PREFIX/$wname
  pkg=${workspaces[$wname]:?Workspace $wname not found.}

  if ! [[ -d "$p" ]]; then
    mkdir -p "$p" # side effect
    # First time opening this workspace, call 'workspace-init'
    cd "$p"
    nix-shell -p "$pkg" --run workspace-init || wait_input_and_exit "Initialisation failed."
  fi

  cd "$p"
  nix-shell -p "$pkg" --run workspace-activate || wait_input_and_exit "Activating failed."
}

USAGE_OPEN="open <workspace name>"
USAGE_LIST="list"

cmd=$1
shift

case "$cmd" in
  "open")
    wname=${1:?Usage: workspaces $USAGE_OPEN}
    open_workspace "$wname"
    ;;

  "list")
    for wname in "${!workspaces[@]}"; do
      echo "$wname"
    done
    ;;

  *)
    cat <<EOF >&2
Usage: workspaces { open | list }

  $USAGE_OPEN
    Open the specified workspace. A directory in $PREFIX is created if it
    doesn't exist, the activation script is run and finally the shell is opened.

  $USAGE_LIST
    List workspaces.
EOF
    ;;
esac
